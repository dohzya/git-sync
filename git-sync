#!/usr/bin/env ruby

opts = {}
remotes = []
while arg = ARGV.shift
  case arg
  when /-a|--all/
    %x(git remote).each_line{|remote| remote.chomp! ; remotes << remote }
  when /-f|--force/
    opts[:force] = true
  when /-p|--prune/
    opts[:prune] = true
  when /-s|--sync/
    opts[:force] = opts[:prune] = true
  when /--dry-run/
    opts[:dry_run] = true
  else
    remotes << arg
  end
end
res = remotes.each do |remote_name|
  next if remote_name.empty?
  puts "#{remote_name}:" if $VERBOSE
  refs = {}
  %x(git show-ref --heads --tags).each_line do |line|
    hash, ref = line.split(/\s+/)
    refs[ref] = hash
  end
  %x(git ls-remote --heads --tags #{remote_name}).each do |line|
    next if line =~ /\^|\sHEAD$/
    hash, ref = line.split(/\s+/)
    refs[ref] = [refs[ref], hash]
  end
  actions = refs.map do |ref, hashes|
    if hashes.is_a? String
      puts "  new ref: #{ref} (#{hashes})" if $VERBOSE
      "#{ref}:#{ref}"
    else
      local, remote = hashes
      case
      when local.nil?
        if opts[:prune]
          puts "  prune ref: #{ref} (#{remote})" if $VERBOSE
          ":#{ref}"
        else
          puts "  orphan ref: #{ref} (#{local})" if $VERBOSE
        end
      when local == remote
        puts "  same ref: #{ref} (#{local})" if $VERBOSE
      else
        puts "  update ref: #{ref} (#{remote} => #{local})" if $VERBOSE
        "#{opts[:force] ? '+' : ''}#{ref}:#{ref}"
      end
    end
  end.compact
  unless actions.empty?
    cmd = "git push #{remote_name} #{actions.join(' ')}"
    if opts[:dry_run]
      puts cmd
    else
      puts cmd if $VERBOSE
      %x(#{cmd})
    end
  end
end
